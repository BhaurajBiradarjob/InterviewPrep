What are HTTP Status Codes?
When a client (browser, Postman, Angular app) sends a request to a server,
the server responds with a status code to tell what happened.
ğŸ“Œ Status codes are 3-digit numbers
ğŸ“Œ First digit tells the category

| Range   | Meaning       | Simple words                   |
| ------- | ------------- | ------------------------------ |
| **1xx** | Informational | â€œRequest received, processingâ€ |
| **2xx** | Success       | â€œEverything is OKâ€             |
| **3xx** | Redirection   | â€œGo somewhere elseâ€            |
| **4xx** | Client Error  | â€œYou did something wrongâ€      |
| **5xx** | Server Error  | â€œServer messed upâ€             |

What are HTTP Verbs?

HTTP verbs (methods) define what action you want to perform on a resource.
ğŸ”‘ Most Important HTTP Verbs
| Verb       | Purpose          | Meaning             |
| ---------- | ---------------- | ------------------- |
| **GET**    | Read             | Fetch data          |
| **POST**   | Create           | Add new data        |
| **PUT**    | Update (full)    | Replace data        |
| **PATCH**  | Update (partial) | Modify part of data |
| **DELETE** | Delete           | Remove data         |

Idempotent â†’ Same result on multiple calls

What is CORS?
CORS = Cross-Origin Resource Sharing
Itâ€™s a browser security rule that controls:
â€œCan a web app from one origin access resources from another origin?â€

ğŸ“Œ Important:
CORS is enforced by the browser, not the server

What is an Origin?

An origin = protocol + domain + port
https://localhost:4200
| Part     | Value     |
| -------- | --------- |
| Protocol | https     |
| Domain   | localhost |
| Port     | 4200      |

Why CORS Exists?
To protect users from malicious websites.

Without CORS:
Any website could call your bank APIs
Steal cookies, tokens, user data ğŸ˜±
So browser says:

â€œIâ€™ll ask the server if this cross-origin call is allowed.â€

How CORS Works (High Level) : 
Browser sends request
Browser checks:
Is this cross-origin?
If yes:
     Apply CORS rules
     If server allows â†’ 
	     request succeeds
     If not â†’
         browser blocks response

ğŸ“Œ Server may process the request
ğŸ“Œ But browser blocks access to response

Q1. What is a RESTful API?
Answer:
A RESTful API follows REST principles and uses HTTP methods like GET, POST, PUT, DELETE to perform operations on resources identified by URLs.

Q2. Difference between PUT and POST?
Answer:
POST â†’ Create new resource
PUT â†’ Update or replace existing resource (idempotent)

Q37. How do you secure APIs?
ğŸ‘‰ API Management + Azure AD + Key Vault

Q1. What is ASP.NET Web API?
Answer:
ASP.NET Web API is a framework for building RESTful HTTP services that can be consumed by clients like browsers, mobile apps, or other services.

Q2. Web API vs MVC?
Answer:
Web API â†’ Builds REST APIs, returns JSON/XML
MVC â†’ Builds web pages (Views)

Q3. What is REST?
Answer:
REST is an architectural style using stateless communication, resource-based URLs, and HTTP verbs.

Q4. What are HTTP verbs?
Answer:
GET, POST, PUT, PATCH, DELETE

Q5. PUT vs PATCH?
Answer:
PUT â†’ Full update
PATCH â†’ Partial update

ğŸ”¹ Routing
Q6. Attribute routing vs conventional routing?
Answer:
Attribute routing â†’ Routes defined on controller/actions
Conventional routing â†’ Centralized routing

Q7. How do you version Web APIs?
Answer:
URL versioning (/api/v1/users)
Header versioning

Query string versioning

Q8. What is API versioning best practice?
Answer:
Use URL or header-based versioning with backward compatibility.

ğŸ”¹ Controllers & Actions
Q9. What is ApiController attribute?
Answer:
Enables automatic model validation, binding, and 400 responses.

Q10. What is IActionResult?
Answer:
Represents various HTTP responses like Ok(), NotFound(), BadRequest().

Q11. When to use ActionResult<T>?
Answer:
When returning both data + HTTP status codes.

ğŸ”¹ Model Binding & Validation
Q12. What is model binding?
Answer:
Maps HTTP request data to action method parameters.

Q13. Model validation?
Answer:
Uses data annotations like [Required], [StringLength].

Q14. How do you handle validation errors?
Answer:
Automatically via [ApiController] or manually checking ModelState.

ğŸ”¹ Filters & Middleware
Q15. What is middleware?
Answer:
Software components that handle requests/responses in a pipeline.

Q16. Filters vs Middleware?
Answer:
Middleware â†’ Cross-cutting, pipeline-level
Filters â†’ Controller/action-level

Q17. Types of filters?
Answer:
Authorization, Action, Result, Exception filters

ğŸ”¹ Dependency Injection
Q18. What is Dependency Injection?
Answer:
Technique to inject dependencies instead of creating them directly.

Q19. Service lifetimes?
Answer:
Singleton
Scoped
Transient

Q20. Scoped vs Singleton?

Answer:
Scoped â†’ per request
Singleton â†’ application lifetime

ğŸ”¹ Authentication & Authorization
Q21. How do you secure Web APIs?
Answer:
Using JWT tokens, OAuth, Azure AD.

Q22. What is JWT?
Answer:
JSON Web Token used for stateless authentication.

Q23. Authentication vs Authorization?
Answer:
Authentication â†’ Who you are
Authorization â†’ What you can access

ğŸ”¹ Exception Handling & Logging
Q24. How do you handle exceptions?
Answer:
Global exception middleware

Exception filters

Q25. How do you log errors?
Answer:
ILogger, Application Insights, Serilog

ğŸ”¹ Performance & Caching
Q26. How do you improve API performance?
Answer:
Caching
Async programming
Pagination
Compression

Q27. What is response caching?
Answer:
Stores responses to avoid repeated processing.

Q28. What is pagination?
Answer:
Breaking large data into pages using skip/take.

ğŸ”¹ Async Programming
Q29. Why async/await?
Answer:
Improves scalability by freeing threads during I/O operations.

Q30. Common async mistakes?
Answer:
Blocking async code
Not awaiting tasks
Deadlocks

ğŸ”¹ Swagger / OpenAPI
Q31. What is Swagger?
Answer:
Auto-generated API documentation and testing UI.

Q32. Why Swagger is important?
Answer:
Documentation, testing, client integration.

ğŸ”¹ Database & EF Core
Q33. EF Core vs Dapper?
Answer:
EF Core â†’ ORM, productivity
Dapper â†’ Micro-ORM, performance

Q34. Tracking vs NoTracking?

Answer:
NoTracking improves read performance.

ğŸ”¹ Real-World Scenarios
Q35. How do you handle long-running tasks?
ğŸ‘‰ Background services / Azure Functions / Service Bus

Q36. How do you handle concurrency?
ğŸ‘‰ Row versioning, optimistic locking

Q37. How do you handle file uploads?
ğŸ‘‰ Multipart/form-data with Blob Storage

Q38. How do you secure secrets?
ğŸ‘‰ Azure Key Vault + Managed Identity

Q39. How do you add health checks?
ğŸ‘‰ AddHealthChecks() + endpoints

Q40. How do you rate-limit APIs?
ğŸ‘‰ API Management / middleware


Singleton : Singleton lifetime services are created the first time when they are requested and then every subsequent request will use the same instance
Scoped :  are created once per request
Transient : are created each time when they are requested

Media type formatters : converts object to json or xml format(client requested format) which is requested by client

Secure ASP.Net web API
A secure API ensures:
    Only trusted clients can call it
    Only authorized users can access data
    Data is protected in transit
    Attacks are blocked or minimized
    Activity is logged and monitored

Basic Security Concepts
1. HTTPS (Must-Have) : Always use HTTPS.
Why?
Encrypts data
Protects tokens, passwords
Prevents MITM attacks

app.UseHttpsRedirection();
ğŸ“Œ Without HTTPS â†’ API is not secure, no matter what else you do.

2. Input Validation : Never trust user input.
public class LoginRequest
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }
}
if (!ModelState.IsValid)
    return BadRequest(ModelState);

Prevents:
SQL Injection
Invalid data crashes

3. Authentication : Authentication proves identity.
| Method           | Used When        |
| ---------------- | ---------------- |
| JWT Bearer Token | Most common      |
| OAuth 2.0        | External login   |
| API Keys         | Server-to-server |
| Cookies          | Browser apps     |

JWT Authentication (Most Used)
Flow:

User logs in
API generates JWT
Client stores token
Client sends token in header
API validates token

4. Authorization â€“ What Can You Access? : Authorization controls permissions.

Role-Based Authorization
[Authorize(Roles = "Admin")]
public IActionResult DeleteUser()

5. CORS â€“ Who Can Call Your API? ğŸ“Œ CORS protects browser clients
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAngular",
        policy =>
            policy.WithOrigins("http://localhost:4200")
                  .AllowAnyHeader()
                  .AllowAnyMethod());
});

6. Protect Secrets & Config (VERY IMPORTANT)
Never hardcode secrets âŒ
Use Secure Storage
| Environment | Use              |
| ----------- | ---------------- |
| Local       | User Secrets     |
| Azure       | Key Vault        |
| CI/CD       | Pipeline secrets |
builder.Configuration["Jwt:Key"];

7. Prevent Common Attacks
SQL Injection

âœ” Use Entity Framework
âœ” Use parameterized queries

Brute Force Protection
Login attempt limits
CAPTCHA
Account lockout

8. Rate Limiting (IMPORTANT)
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("fixed",
        opt =>
        {
            opt.Window = TimeSpan.FromMinutes(1);
            opt.PermitLimit = 100;
        });
});

Prevents:

DDoS
Abuse

9. Logging & Monitoring
Log Security Events

Failed logins
Token validation failures
Unauthorized access

logger.LogWarning("Unauthorized access attempt");

Use App Insights / ELK / Logstash

Track:
401 / 403 spikes
Suspicious IPs
Latency

10. API Design Security Best Practices

âœ” Least privilege
âœ” Version APIs
âœ” Hide internal errors
âœ” Use correct HTTP status codes
âœ” Validate request size

return StatusCode(500, "Something went wrong");
âŒ Do not expose stack traces

11. Enterprise Security
OAuth 2.0 + OpenID Connect
Used with:
Azure Entra ID
IdentityServer
Auth0

Flow:
Token issued by Identity Provider
API trusts issuer
Think in layers, not one feature.

12. Managed Identity (Azure)

No secrets
Secure service-to-service auth

13. mTLS (Advanced)
Client certificate authentication
Used in banking, healthcare

| Layer          | Purpose          |
| -------------- | ---------------- |
| HTTPS          | Encrypt data     |
| Authentication | Who you are      |
| Authorization  | What you can do  |
| CORS           | Who can call     |
| Validation     | Input safety     |
| Rate limiting  | Abuse prevention |
| Secrets mgmt   | Protect keys     |
| Monitoring     | Detect attacks   |


Kestrel Server : 
what problem does Kestrel solve? 
When a client (browser, mobile app, Postman) sends an HTTP request, something must listen on a port, accept that request, and pass it to your app.
That â€œsomethingâ€ is a web server.

ğŸ‘‰ In ASP.NET Core, that web server is Kestrel.

What is Kestrel Server?
Kestrel is a cross-platform, high-performance web server built into ASP.NET Core.
Written in C#
Part of ASP.NET Core
Listens for HTTP requests
Handles HTTP/1.1, HTTP/2, HTTP/3
Works on Windows, Linux, macOS

Q1: Is Kestrel mandatory in ASP.NET Core?
âœ… Yes, ASP.NET Core always runs on Kestrel (directly or behind proxy).

Q2: Can Kestrel replace IIS?
â¡ï¸ Partially
For containers & Linux â†’ yes
For Windows auth & enterprise hosting â†’ IIS still useful

Q3: Is Kestrel secure?

âœ… Yes, but:
Should be behind a reverse proxy for public apps
HTTPS + headers handled better by proxy

Different asp.net web api classes
Controller class : handles incoming http requests.
Model class : represents data
service class : performs business operations, data manipulation, validation
Middleware : handles request and responses in asp.net pipelines
Repository : handles data access operations
Configuration class : application specific config
Exception class: custom exceptions

Middleware : Middleware is a piece of code that runs on every HTTP request and response.

It can:
Inspect the request
Modify the request
Pass it forward
Inspect/modify the response
Short-circuit the pipeline

Client
 â†“
Middleware 1
 â†“
Middleware 2
 â†“
Middleware 3
 â†“
Endpoint (Controller / Minimal API)
 â†‘
Middleware 3
 â†‘
Middleware 2
 â†‘
Middleware 1
 â†‘
Response to Client

ğŸ” Middleware runs twice:
On the way in (request)
On the way out (response)

3. Why Middleware Exists

Without middleware:
Every controller would handle:

Authentication
Logging
Error handling
CORS
Security headers

ğŸ‘‰ Massive duplication âŒ

Middleware solves this by handling cross-cutting concerns centrally.

4. Built-in Middleware
ASP.NET Core gives many middleware out of the box:
| Middleware              | Purpose                 |
| ----------------------- | ----------------------- |
| `UseRouting()`          | Matches URL to endpoint |
| `UseAuthentication()`   | Identifies user         |
| `UseAuthorization()`    | Checks permissions      |
| `UseCors()`             | Handles CORS            |
| `UseExceptionHandler()` | Global error handling   |
| `UseHttpsRedirection()` | Redirect HTTP â†’ HTTPS   |
| `UseStaticFiles()`      | Serve CSS/JS/images     |

Typical correct order
app.UseExceptionHandler();
app.UseHttpsRedirection();

app.UseRouting();

app.UseCors();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

5. Use -> Can pass request to next middleware
app.Use(async (context, next) =>
{
    // before
    await next();
    // after
});

6. Run -> Terminal middleware, Stops pipeline
app.Run(async context =>
{
    await context.Response.WriteAsync("Hello");
});
Anything after Run âŒ will never execute.

7. Map -> Branches pipeline by path
app.Map("/admin", adminApp =>
{
    adminApp.Run(async context =>
    {
        await context.Response.WriteAsync("Admin area");
    });
});

ğŸ“Œ Use middleware for:

Auth
Logging
Exception handling

Q1: Does middleware execute in order?
âœ… Yes, order defined in Program.cs

Q2: Can middleware modify response?
âœ… Yes, after await next()

Q3: Can middleware skip controllers?
âœ… Yes, via short-circuiting

Q4: Can we inject services into middleware?
âœ… Yes, via constructor DI

What is Logging?
Logging means recording what your application is doing at runtime.

You log things like:

Requests coming in
Errors/exceptions
Warnings
Important business events
Performance issues

Why Logging is CRITICAL in Web APIs

Without logging:
Bugs are invisible âŒ
Production issues are impossible to debug âŒ
Support teams panic âŒ

With logging:
You know what failed
When it failed
Why it failed
Which request/user caused it

Built-in Logging in ASP.NET Core
ASP.NET Core has logging built-in by default ğŸ‰

It uses:
ILogger<T>
Logging Providers
Log Levels

No extra setup needed initially.

public class WeatherController : ControllerBase
{
    private readonly ILogger<WeatherController> _logger;

    public WeatherController(ILogger<WeatherController> logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IActionResult Get()
    {
        _logger.LogInformation("Weather API called");
        return Ok();
    }
}

Log Level

| Level           | When to use                 |
| --------------- | --------------------------- |
| **Trace**       | Very detailed, step-by-step |
| **Debug**       | Development debugging       |
| **Information** | Normal app flow             |
| **Warning**     | Unexpected but handled      |
| **Error**       | Failure, but app continues  |
| **Critical**    | App crash / system failure  |

_logger.LogWarning("Invalid input received");
_logger.LogError(ex, "Database connection failed");

Logging Configuration (appsettings.json)
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

| Provider             | Usage         |
| -------------------- | ------------- |
| Console              | Development   |
| Debug                | Visual Studio |
| EventLog             | Windows       |
| File                 | Production    |
| Application Insights | Azure         |
| Serilog / NLog       | Advanced      |


âœ… Do

Log once, not everywhere
Use structured logging
Log context (RequestId, UserId)
Use correct log levels
Centralize logs (App Insights)

âŒ Donâ€™t

Log sensitive data (passwords, tokens)
Over-log (performance hit)
Use Console.WriteLine
Catch exceptions only to log and ignore

Q1: Is logging synchronous?
âŒ No, itâ€™s asynchronous (non-blocking)

Q2: Should controllers log errors?
âš ï¸ No â€” let exception middleware log errors

Q3: Difference between logging and tracing?
Logging â†’ Events
Tracing â†’ Request flow across services

What is an Exception?
An exception is an error that occurs while your application is running.

Examples:

Database connection failed
Null reference
Divide by zero
Invalid input
External API timeout

If not handled â†’ app crashes or returns ugly errors âŒ

Why Exception Handling is IMPORTANT

Without proper handling:
App crashes âŒ
Client gets stack traces âŒ
Security risk âŒ
Debugging becomes nightmare âŒ

With proper handling:
App stays alive âœ…
Client gets clean error response âœ…
Errors are logged properly âœ…

Naive Approach: tryâ€“catch everywhere

[HttpGet]
public IActionResult Get()
{
    try
    {
        var data = service.GetData();
        return Ok(data);
    }
    catch (Exception ex)
    {
        return StatusCode(500, ex.Message);
    }
}
Why this is BAD âŒ

Duplicate code
Controllers become messy
No centralized handling
Easy to forget logging

ğŸ‘‰ Not scalable

Correct Way: Centralized Exception Handling (Key idea ğŸ”‘)

Exceptions should be handled in ONE place, not everywhere.

ASP.NET Core gives 3 main ways:
Exception Handling Middleware âœ… (BEST)
Exception Filters
Developer Exception Page (Dev only)

Exception Handling Middleware (Most important ğŸ”¥)
Why middleware is best?

Catches all unhandled exceptions
Centralized
Clean controllers
Works for entire pipeline

app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        context.Response.StatusCode = 500;
        context.Response.ContentType = "application/json";

        await context.Response.WriteAsync(
            "{\"error\":\"Something went wrong\"}"
        );
    });
});
ğŸ“Œ Must be registered early in pipeline.

Exception Handling + Logging (Real-world)
app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        var logger = context.RequestServices
            .GetRequiredService<ILogger<Program>>();

        var exception = context.Features
            .Get<IExceptionHandlerFeature>()?.Error;

        logger.LogError(exception, "Unhandled exception");

        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new
        {
            Message = "Internal Server Error"
        });
    });
});
ğŸ‘‰ Client sees safe message
ğŸ‘‰ Logs contain real exception

HTTP Status Codes for Exceptions (Very important)

| Scenario              | Status Code     |
| --------------------- | --------------- |
| Validation error      | 400 Bad Request |
| Unauthorized          | 401             |
| Forbidden             | 403             |
| Not found             | 404             |
| Business rule failure | 409 Conflict    |
| Server error          | 500             |

Why custom exceptions?
Separate business errors from system errors
Clean error mapping

Q1: Middleware vs Exception Filter?
Middleware â†’ whole pipeline âœ…
Filter â†’ MVC only âŒ

Q2: Where should exceptions be logged?
ğŸ‘‰ Global exception middleware

Q3: Should services throw exceptions?
âœ… Yes, donâ€™t swallow them







ğŸ”¹ Interview One-liners (Memorize ğŸ”¥)

Web API â†’ RESTful HTTP services

Middleware â†’ Request pipeline

JWT â†’ Stateless auth

DI â†’ Loose coupling

Async â†’ Scalability

If you want next:

Advanced Web API coding questions

System design using Web API

Common Web API mistakes

Mock ASP.NET Web API interview



MVC
Model
What it does:
Represents data and business logic
Talks to the database
Applies rules (validations, calculations)

View
What it does:
Responsible for UI (User Interface)
Displays data to the user
No business logic

Controller
What it does:
Acts as a middleman
Handles user requests
Fetches data from Model
Sends data to View

How MVC Works (Flow)

User opens a URL
Controller receives the request
Controller gets data from Model
Controller sends data to View
View displays it to the user

ğŸ“Œ Flow:
User â†’ Controller â†’ Model â†’ Controller â†’ View â†’ User

âœ… Advantages of MVC
Clean separation of concerns
Easy to maintain and test
Multiple views can use the same model
Great for large applications