What is ASP.NET Core Pipeline?

API Request Lifecycle (ASP.NET Core)
1. Client Sends HTTP Request
2. Web Server (Kestrel / IIS)
3. Middleware Pipeline Begins
Request
 ‚Üì
Exception Middleware
 ‚Üì
Routing Middleware
 ‚Üì
Authentication Middleware
 ‚Üì
Authorization Middleware
 ‚Üì
Endpoint Middleware
4. Routing (Endpoint Selection)
5. Authentication
6. Authorization
7. Model Binding -> Reads request data, Converts JSON ‚Üí C# object
8. Model Validation -> Uses Data Annotations
[Required]
[StringLength(50)]
public string Name { get; set; }
If invalid:
400 Bad Request
{
  "errors": { ... }
}
9. Filters Execution
10. Controller Action Executes
11. Response Travels Back Through Middleware
12. Server Sends HTTP Response

Client ‚Üí Kestrel ‚Üí Middleware ‚Üí Routing ‚Üí Auth ‚Üí Authorization ‚Üí Model Binding -> Model Validation ‚Üí Filters ‚Üí Controller ‚Üí Response ‚Üí Client

2. Have you written any middleware?
Yes, I have written custom middleware in ASP.NET Core.

What is Middleware? (Quick recap)
Middleware is a component in the ASP.NET Core request pipeline that:

Handles HTTP requests
Can inspect / modify the request
Can call the next middleware
Can inspect / modify the response

Request ‚Üí Middleware ‚Üí Controller ‚Üí Middleware ‚Üí Response

Middleware I Have Written 
1. Global Exception Handling Middleware
Used to:

Catch unhandled exceptions
Return consistent error responses
Log errors

public class ExceptionMiddleware
{
    private readonly RequestDelegate _next;

    public ExceptionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            context.Response.StatusCode = 500;
            await context.Response.WriteAsJsonAsync(new
            {
                Message = "Something went wrong"
            });
        }
    }
}

2. Logging Middleware
Used to:

Log request & response
Measure execution time

var start = Stopwatch.StartNew();
await _next(context);
start.Stop();
_logger.LogInformation($"Request took {start.ElapsedMilliseconds}ms");

3. Authentication / Authorization Middleware

Used to:
Validate JWT tokens
Extract user claims
Reject unauthorized requests

4. CORS / Header Middleware

Used to:
Add security headers
Modify request headers

How I Register Middleware : 
app.UseMiddleware<ExceptionMiddleware>();

app.UseExceptionMiddleware();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

Why Write Custom Middleware?

‚úî Reusability
‚úî Centralized logic
‚úî Cleaner controllers
‚úî Performance-friendly
‚úî Easy to maintain

Yes, I‚Äôve written custom middleware for exception handling, logging, authentication, and request tracing in ASP.NET Core

What are Filters?
Filters are components in ASP.NET Core MVC that run before or after controller actions.

Request
 ‚Üí Middleware
   ‚Üí Routing
     ‚Üí Filters
       ‚Üí Controller Action
     ‚Üí Filters
 ‚Üí Middleware
Response
‚úî Filters run inside MVC pipeline

Types of Filters
1. Authorization Filters : Authorization checks
IAuthorizationFilter -> contains OnAuthorization method

[Authorize]

2. Resource Filters : Run before model binding
Used for: Caching, Short-circuiting requests

IResourceFilter -> contains OnResultExecuted, OnResultExecuting method

3. Action Filters : Run before & after action method
Used for: Logging, Validation, Auditing

IActionFilter -> contains OnActionExecuted, OnActionExecuting method
IAsyncActionFilter

4. Exception Filters : Run when exception occurs
Used for: Handling exceptions in controllers

IExceptionFilter -> contains OnException method

5. Result Filters : Run before & after result execution
Used for: Modifying response

IResultFilter -> contains OnResultExecuted, OnResultExecuting method

Example: Action Filter
public class LoggingFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Before action
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // After action
    }
}
[ServiceFilter(typeof(LoggingFilter))]
public IActionResult Get() { }

| Feature             | Middleware          | Filters                       |
| ------------------- | ------------------- | ----------------------------- |
| Scope               | Global              | MVC only                      |
| Runs for            | All requests        | Controller actions            |
| Pipeline position   | Before routing      | After routing                 |
| HTTP context access | Full                | Limited to MVC                |
| Use cases           | Auth, CORS, logging | Validation, caching, auditing |
| Can short-circuit   | Yes                 | Yes                           |
| Dependency on MVC   | ‚ùå No                | ‚úÖ Yes                         |

4. What is the advantage of Glabal middleware?
Global middleware is middleware that is registered once and runs for every incoming HTTP request.

app.UseMiddleware<GlobalExceptionMiddleware>();
‚úÖ Advantages of Global Middleware
1. Centralized Cross-Cutting Logic
You write the logic once and it applies everywhere.

Examples:

Exception handling
Authentication
Logging
Correlation IDs
CORS
Security headers

‚úî No duplicate code
‚úî Consistent behavior across APIs

2. Runs for Every Request (Not Just Controllers)
Global middleware runs for:

APIs
MVC controllers
Minimal APIs
Static files
Health checks

üëâ Filters cannot do this.

3. Cleaner Controllers

Controllers focus only on:

Business logic
Request/response handling

4. Early Request Short-Circuiting
Middleware can stop requests before they hit controllers.

Examples:
Invalid token
Blocked IP
Maintenance mode
Rate limiting

context.Response.StatusCode = 401;
return;

5. Better Performance for Infrastructure Concerns
Middleware:
Runs earlier
Has less overhead than MVC filters

Ideal for:
Authentication
Logging
Request validation

6. Full Access to HTTP Context

Global middleware has access to:

Headers
Body
Cookies
Path
Response stream

This makes it ideal for:

Custom headers
Request transformations
Security enforcement

7. Consistent Error Handling

With global exception middleware:

Same error format everywhere
Centralized logging
Easy monitoring & alerting

We used global middleware for exception handling, logging, authentication, and correlation ID generation. 
This allowed us to centralize cross-cutting concerns, keep controllers clean, and ensure consistent behavior and 
error responses across all APIs.

Global middleware provides centralized, reusable handling of cross-cutting concerns for all requests, improving consistency,
 performance, and maintainability.
 performance, and maintainability.

Global middleware is best suited for infrastructure-level concerns, while filters should be used for MVC-specific behavior.

What is Dependency Injection?

Dependency Injection is a design pattern where:
An object does not create its dependencies Instead, dependencies are provided (injected) from outside

üìå In ASP.NET Core, DI is built-in (no extra framework needed).

Why DI is Important?

‚úî Loose coupling
‚úî Easy testing (mocking)
‚úî Better maintainability
‚úî Follows SOLID principles
‚úî Enterprise-ready architecture

How DI Works Internally (Flow)
App starts
Services registered in container
Request comes in
Container creates controller
Injects required dependencies
Disposes based on lifetime

Types of Dependency Injection
1. Constructor Injection (Recommended ‚úÖ)
public class UserController : ControllerBase
{
    private readonly IUserService _service;

    public UserController(IUserService service)
    {
        _service = service;
    }
}
‚úî Most common
‚úî Clear dependencies
‚úî Best practice

2. Method Injection : Use sparingly.
public IActionResult Get([FromServices] ILogger logger)

3. Property Injection ‚ùå Not supported by default.

Service Lifetimes (VERY IMPORTANT üî•)
1. Transient
services.AddTransient<IService, Service>();

New instance every time
Lightweight, stateless services

2. Scoped (Most Used in Web Apps)
services.AddScoped<IService, Service>();

One instance per HTTP request
Perfect for DB contexts

üìå DbContext should always be Scoped

3. Singleton
services.AddSingleton<IService, Service>();

Single instance for entire app
Shared across requests
‚ö†Ô∏è Must be thread-safe

| Lifetime  | Instance        |
| --------- | --------------- |
| Transient | Every injection |
| Scoped    | Per request     |
| Singleton | Per application |

5. What is a Clustered Index?

A clustered index determines how the data is physically stored on disk or table.
üëâ In a table with a clustered index:
Rows are stored in the order of the clustered index key
The table data is the index

When Clustered Index Helps Most

‚úî Large tables
‚úî Range queries
‚úî Sorting
‚úî Reporting queries

Interview One-Liners (üí• Must Say)
‚ÄúClustered index defines physical order of data‚Äù
‚ÄúOnly one clustered index per table‚Äù
‚ÄúLeaf nodes contain actual data‚Äù
‚ÄúPrimary key is not always clustered‚Äù
‚ÄúGood clustered index improves range queries‚Äù
A clustered index determines the physical order of rows in a table and stores the actual data at the leaf level of the index.

Example (Very Important ‚≠ê)
Table: Employees
EmpId	Name	Salary

If EmpId is a clustered index:

Rows are stored on disk sorted by EmpId

Querying by EmpId is very fast

CREATE CLUSTERED INDEX IX_Employees_EmpId
ON Employees(EmpId);

Clustered Index vs Heap
üîπ Heap (No clustered index)

Data stored unordered
SQL Server scans entire table

üîπ Clustered Index

Data stored in sorted order
Faster searches, range queries

üëâ By default:

Primary Key ‚Üí creates clustered index (unless specified otherwise)

Why only one Clustered Index?

Because:

Table rows can be physically ordered only once
Multiple orderings = impossible at storage level

When should you use Clustered Index?

Best columns:

‚úî Primary Key
‚úî Unique
‚úî Sequential values
‚úî Frequently used in WHERE, JOIN, ORDER BY, BETWEEN

Examples:

Id
CreatedDate
OrderId

When NOT to use Clustered Index on a column?

Avoid:

‚ùå Frequently updated columns
‚ùå Random values (GUID without sequential)
‚ùå Very wide columns

Why?

Causes page splits
Performance degradation

| Feature         | Clustered Index          | Non-Clustered Index |
| --------------- | ------------------------ | ------------------- |
| Physical order  | Yes                      | No                  |
| Leaf nodes      | Actual data              | Pointers to data    |
| Count per table | 1                        | Multiple            |
| Storage         | Table itself             | Separate structure  |
| Speed           | Faster for range queries | Faster for lookups  |

SELECT * FROM Orders
WHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';

‚úî If OrderDate is clustered ‚Üí very fast
‚ùå If heap ‚Üí full table scan

Can we have a table without a clustered index?
‚úî Yes ‚Üí it‚Äôs called a Heap

Can primary key be non-clustered?
‚úî Yes (explicitly specify)
PRIMARY KEY NONCLUSTERED

A clustered index determines the physical order of data in a table. It stores the actual data at the leaf level, allows only one per table, and is best suited for primary keys and range 
queries.

6. What are Standalone Components?
A Standalone Component is an Angular component that does NOT need to be declared in an NgModule.

üëâ Earlier:
Every component had to belong to a module

üëâ Now:
A component can stand alone
It can directly manage its own dependencies

Standalone components are Angular components that can be used without declaring them inside an NgModule.

Module : 
@NgModule({
  declarations: [UserComponent],
  imports: [CommonModule],
})
export class UserModule {}

‚ùå More boilerplate
‚ùå Harder to manage large apps

Standalone Component (Angular 14+)
@Component({
  selector: 'app-user',
  standalone: true,
  imports: [CommonModule],
  template: `<h2>User Component</h2>`
})
export class UserComponent {}
‚úÖ No module
‚úÖ Self-contained
‚úÖ Cleaner architecture

| Feature               | NgModule-based | Standalone      |
| --------------------- | -------------- | --------------- |
| Requires module       | Yes            | No              |
| Boilerplate           | More           | Less            |
| Dependency management | In module      | In component    |
| Lazy loading          | Module-based   | Component-based |
| Modern Angular        | ‚ùå              | ‚úÖ               |

‚ùì Are NgModules deprecated?
‚û°Ô∏è No. They are still supported.

‚ùì Can standalone and module-based components coexist?
‚û°Ô∏è Yes, Angular fully supports hybrid apps.

‚ùì Do standalone components improve performance?
‚û°Ô∏è Yes, better tree-shaking and lazy loading.

Standalone components in Angular allow developers to create self-contained components without NgModules, simplifying architecture, reducing boilerplate, and enabling better lazy loading.

7. What are Components and Directives?
A Component is a building block of the UI.

üëâ It:
Controls a view (HTML)
Has logic (TypeScript)
Uses CSS for styling

@Component({
  selector: 'app-user',
  template: `<h2>Hello {{name}}</h2>`
})
export class UserComponent {
  name = 'John';
}

üìå Components:

Always have a template
Always display something on the screen

What is a Directive? 
A Directive is used to change the behavior or appearance of an existing DOM element.

üëâ It does not create UI
üëâ It modifies UI
A directive adds behavior to an existing element.

Types of Directives (Very Important ‚≠ê)

1. Structural Directives : Change the DOM structure
Examples:

*ngIf
*ngFor
*ngSwitch

<div *ngIf="isLoggedIn">Welcome</div>
üëâ Adds or removes elements from DOM

2. Attribute Directives : Change appearance or behavior
Examples:

ngClass
ngStyle
Custom directives

<div [ngClass]="{ active: isActive }"></div>

Custom Directive Example
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'yellow';
  }
}

<p appHighlight>Highlighted text</p>

| Feature              | Component    | Directive    |
| -------------------- | ------------ | ------------ |
| Has template         | ‚úÖ Yes        | ‚ùå No         |
| Creates UI           | ‚úÖ Yes        | ‚ùå No         |
| Modifies existing UI | ‚ùå            | ‚úÖ            |
| Decorator            | `@Component` | `@Directive` |
| Reusability          | UI blocks    | Behavior     |


@Component === @Directive + Template
A component is a directive with a template.

Component : 

Header
Footer
Login form
Dashboard

Directive :

Permission checks
Auto focus
Input formatting
Role-based UI hiding

‚ÄúComponents manage views; directives modify existing elements.‚Äù
‚ÄúStructural directives change DOM structure.‚Äù
‚ÄúAttribute directives change appearance or behavior.‚Äù
‚ÄúEvery component is a directive with a template.‚Äù

‚ùì Can a directive have a template?
‚ùå No

‚ùì Can a component exist without HTML?
‚ùå No

‚ùì Which is more reusable?
‚úî Directive (behavior reuse)

Component ‚Üí What you SEE
Directive ‚Üí How it BEHAVES

8. How do make an Angular Component Singleton?
üëâ Angular components themselves are NOT meant to be singletons.
üëâ Services are what Angular makes singleton ‚Äî not components.

Why Components Are NOT Singletons

Components are created and destroyed by Angular
Routing, *ngIf, lazy loading ‚Üí new instances
Angular lifecycle controls component instances
Even if a component appears once, Angular does not guarantee singleton behavior.

The CORRECT Way: Use a Singleton Service ‚≠ê
@Injectable({
  providedIn: 'root'
})
export class UserStateService {
  username = 'John';
}

‚úî providedIn: 'root' ‚Üí Singleton for entire app

Inject service into component
@Component({
  selector: 'app-profile',
  template: `{{ state.username }}`
})
export class ProfileComponent {
  constructor(public state: UserStateService) {}
}


Angular components cannot be singletons because they are managed by the framework lifecycle. 
To achieve singleton behavior or shared state, we use a singleton service (providedIn: 'root') and 
inject it into the component.

What is providedIn?
providedIn tells Angular where a service should be registered in the Dependency Injection hierarchy.

All possible values of providedIn

Angular supports 4 main values:

'root'
'platform'
'any'
null (or not specified)

providedIn: 'root' (Most common ‚≠ê)
What it means

Service is registered in the root injector
Singleton for entire application

Characteristics

‚úî One instance across app
‚úî Shared between all modules
‚úî Tree-shakable
‚úî Recommended default

Use cases

Auth
API services
Shared state
Logging

providedIn: 'platform'
What it means

Service is shared across multiple Angular apps
Registered at platform level

‚úî Single instance across multiple apps

providedIn: 'any' (Advanced ‚ö†Ô∏è)
What it means

One instance per lazy-loaded module
Shared within eager-loaded modules

Eager modules ‚Üí share one instance
Lazy modules ‚Üí get their own instance

providedIn: null or Not Specified
What it means

Angular does not auto-register service
You must manually add it to providers


| Value      | Scope           | Singleton? | Tree-shakable | Common? |
| ---------- | --------------- | ---------- | ------------- | ------- |
| `root`     | App-wide        | Yes        | Yes           | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê   |
| `platform` | Multi-app       | Yes        | Yes           | ‚≠ê       |
| `any`      | Per lazy module | Sometimes  | Yes           | ‚≠ê‚≠ê      |
| `null`     | Manual          | Depends    | No            | ‚≠ê‚≠ê      |

root ‚Üí ‚ÄúSingleton across the app‚Äù
platform ‚Üí ‚ÄúShared across multiple Angular apps‚Äù
any ‚Üí ‚ÄúNew instance per lazy module‚Äù
null ‚Üí ‚ÄúManual provider registration‚Äù

9. How would you document your APIs? 
I Document APIs Using Swagger. 
In ASP.NET Core, Swagger is the default and recommended approach.

What is Swagger?

Swagger (OpenAPI) is:
A machine-readable API specification
Auto-generated from code
Interactive UI to test APIs

I primarily document my APIs using Swagger/OpenAPI in ASP.NET Core because it‚Äôs auto-generated, always in sync with code, 
and easy for consumers to test.
In addition, I maintain a README or Wiki to explain authentication flows, error handling, rate limits, and versioning.
For collaboration, I also share Postman collections so frontend and QA teams can work independently.

10. Any issues implementing JWT tolens?
1. Token Expiry Issues (401 errors suddenly)
Problem:
Users were getting 401 Unauthorized even though they were logged in.
JWT access tokens expired (e.g., 15 minutes).

Why it happens:
JWT is stateless ‚Üí server does NOT track sessions.
Once expired, token is invalid.

Solution:
Implemented Refresh Token mechanism
Short-lived Access Token (10‚Äì15 mins)
Long-lived Refresh Token (7‚Äì30 days)
Client silently calls /refresh-token when access token expires

2. Secure Storage of JWT on Client

| Storage              | Risk      | Used When         |
| -------------------- | --------  | ----------------- |
| localStorage         | XSS       | Avoid if possible |
| sessionStorage       | XSS       | Slightly better   |
| **HttpOnly Cookies** | ‚úÖ Secure | **Best practice** |

Solution I used:

Stored access token in memory
Stored refresh token in HttpOnly + Secure cookie

3. Token Theft / Replay Attacks
Problem:
If JWT is stolen, attacker can use it till expiry.

Mitigation steps:
Very short access token lifetime
HTTPS enforced (RequireHttpsMetadata)
Added Audience, Issuer, SigningKey validation
Used rotating refresh tokens

4. Logout Not Working Properly
Problem:

JWT is stateless ‚Üí server can‚Äôt ‚Äúdelete‚Äù a token

Solutions:

On logout:
Delete refresh token from DB
Clear HttpOnly cookie
Optional:
Maintain token blacklist (for critical systems)

‚úÖ Logout became effective immediately.

5. Large JWT Payload (Performance Issue)
Problem:

JWT size increased (roles, permissions, claims)
Increased request header size ‚Üí performance hit

Solution:

Kept JWT minimal

Stored only:

UserId
Role
Loaded permissions from cache/DB if needed

‚úÖ Faster requests + smaller tokens.

6. Refresh Token Reuse Attack

Problem:
Same refresh token used multiple times

Solution (Best Practice):
Rotate refresh tokens

On refresh:
Invalidate old refresh token
Issue a new one
If reuse detected ‚Üí revoke all tokens

‚úÖ Improved security drastically.

11. What is the cycle of API request?
API Request Lifecycle (ASP.NET Core)
1. Client Sends HTTP Request
2. Web Server (Kestrel / IIS)
3. Middleware Pipeline Begins
Request
 ‚Üì
Exception Middleware
 ‚Üì
Routing Middleware
 ‚Üì
Authentication Middleware
 ‚Üì
Authorization Middleware
 ‚Üì
Endpoint Middleware
4. Routing (Endpoint Selection)
5. Authentication
6. Authorization
7. Model Binding -> Reads request data, Converts JSON ‚Üí C# object
8. Model Validation -> Uses Data Annotations
[Required]
[StringLength(50)]
public string Name { get; set; }
If invalid:
400 Bad Request
{
  "errors": { ... }
}
9. Filters Execution
10. Controller Action Executes
11. Response Travels Back Through Middleware
12. Server Sends HTTP Response

Client ‚Üí Kestrel ‚Üí Middleware ‚Üí Routing ‚Üí Auth ‚Üí Authorization ‚Üí Model Binding ‚Üí Filters ‚Üí Controller ‚Üí Response ‚Üí Client

12. Did you work on Custom middleware?
Yes, Custom middleware is code that:

Executes on every request
Runs before and after the next component
Handles cross-cutting concerns

Example 1: Global Exception Handling Middleware
Example 2: Request & Response Logging
Example 3: Custom Header Validation
Example 4: Tenant / Correlation ID Middleware
Yes, I have implemented custom middleware in ASP.NET Core. I mainly used it for global exception handling, 
request‚Äìresponse logging, and validating custom headers. Middleware helped me centralize cross-cutting concerns instead of 
duplicating logic in controllers. 
It runs early in the request pipeline and improves maintainability, observability, and consistency across APIs

13. What different types of Rest APIs did you know and use?
1. CRUD-Based REST APIs (Most Common)
APIs that map HTTP verbs to database operations.
| Operation | HTTP Verb   | Example        |
| --------- | ----------- | -------------- |
| Create    | POST        | `/api/users`   |
| Read      | GET         | `/api/users/1` |
| Update    | PUT / PATCH | `/api/users/1` |
| Delete    | DELETE      | `/api/users/1` |
2. Resource-Oriented APIs : API is designed around resources, not actions.
/users/{id}
3. Stateless REST APIs : Server does not store client session, Every request contains authentication info (JWT)
4. Secured REST APIs : APIs protected using JWT, OAuth 2.0, Role & policy-based authorization
5. Versioned REST APIs : Backward compatibility, Safe evolution of APIs
/api/v1/users
/api/v2/users
6. Async / High-Performance REST APIs : Uses async/await, Non-blocking I/O
7. Idempotent REST APIs : Multiple identical requests produce same result.
Used in:
PUT
DELETE

Example:
Calling DELETE multiple times ‚Üí same final state.
8. REST APIs with Pagination, Filtering & Sorting :
GET /api/users?page=1&pageSize=20&sort=name

I have worked with multiple types of REST APIs including CRUD-based, resource-oriented, stateless, secured, and 
versioned APIs. Most of the APIs I built were JWT-secured, async, and followed REST best practices like proper HTTP verbs,
 idempotency, pagination, and versioning. 
I have also handled internal APIs for microservices and external APIs for client applications.

14. If you want to pass data from 1 middleware to other middleware how do you do it?
HttpContext
Why HttpContext.Items?

Per-request storage
Thread-safe
Automatically cleared after request
Designed exactly for this purpose

To pass data from one middleware to another, I use HttpContext.Items. It provides per-request storage that is shared 
across the middleware pipeline.
 One middleware can store data in HttpContext.Items, and downstream middleware can read it. 
 Since the same HttpContext flows through the pipeline, 
 this approach is thread-safe and commonly used for correlation IDs, tenant information, and logging.
 
15. How will you make a service available to the controller?
In ASP.NET Core, controllers do not create objects directly.

Instead:

Services are registered in the DI container, Controllers request them via constructor injection

This is called Dependency Injection.

| Lifetime  | When to Use            |
| --------- | ---------------------- |
| Singleton | Config, cache          |
| Scoped    | DB, business services  |
| Transient | Lightweight, stateless |


In ASP.NET Core, I make a service available to a controller using dependency injection. 
I register the service in the built-in DI container with an appropriate lifetime and inject it into the controller via 
constructor injection.
This approach promotes loose coupling, testability, and clean architecture.

16. Lifetime of a service with in a core?
Service Lifetimes (VERY IMPORTANT üî•)
1. Transient
services.AddTransient<IService, Service>();

New instance every time
Lightweight, stateless services

2. Scoped (Most Used in Web Apps)
services.AddScoped<IService, Service>();

One instance per HTTP request
Perfect for DB contexts

üìå DbContext should always be Scoped

3. Singleton
services.AddSingleton<IService, Service>();

Single instance for entire app
Shared across requests
‚ö†Ô∏è Must be thread-safe

| Lifetime  | Instance        |
| --------- | --------------- |
| Transient | Every injection |
| Scoped    | Per request     |
| Singleton | Per application |

17. How to Optimize Performance of ASP.NET Web API

Performance optimization happens at multiple layers:

Application level
Database level
Infrastructure level
Network level

1. Use Asynchronous Programming
Why?

Frees thread while waiting for I/O
Handles more concurrent requests
Improves scalability

üö® Never block threads:
.Result
.Wait()

2. Optimize Database Queries
‚úÖ Use Proper Indexing

Clustered index on primary key
Non-clustered indexes on frequently filtered columns

‚úÖ Select Only Required Columns

‚úÖ Use AsNoTracking() for Read-Only Queries

‚úÖ Avoid N+1 Queries

‚úÖ Use Include:

3. Enable Caching (Huge Performance Boost üöÄ)
‚úÖ In-Memory Cache : IMemoryCache

‚úÖ Distributed Cache : Redis, SQL Server cache

‚úÖ Response Caching : [ResponseCache(Duration = 60)]

‚úÖ Output Caching (.NET 7+) : app.UseOutputCache();

4. Use Pagination
‚ùå Never return 100,000 records.

.Skip((page - 1) * pageSize)
.Take(pageSize)

Reduces:

Memory usage
Network load
Database load

5. Enable Compression
builder.Services.AddResponseCompression();
Reduces response size ‚Üí faster API

6. Use Connection Pooling

Built-in with SQL Server.

Avoid:
Opening/closing connections manually
Creating DbContext manually
Use DI.

7. Use Rate Limiting

Prevents overload:

builder.Services.AddRateLimiter();

8. Minimize Middleware

Too many middleware = slower pipeline.

9. Use Background Services for Heavy Work

Move heavy processing to:

Azure Service Bus
RabbitMQ
Hangfire
BackgroundService

Never block API request for heavy work.

10. Use Profiling Tools

Application Insights
MiniProfiler
SQL Profiler
dotTrace
BenchmarkDotNet
Measure before optimizing.

18. What is Caching?
Caching means storing frequently used data temporarily so we don‚Äôt fetch it again and again 
from the original source (like a database).

üëâ Instead of:
Client ‚Üí API ‚Üí Database (every time ‚ùå)

We do:
Client ‚Üí API ‚Üí Cache (fast ‚úÖ)
                ‚Üì
              Database (only first time)

Why Do We Need Caching?

Without caching:

Database gets overloaded
API becomes slow
More CPU & memory usage
Poor scalability

With caching:

Faster response
Reduced DB load
Better user experience
Lower infrastructure cost

Real-Life Example

Imagine:

10,000 users request product list

Same data for everyone

Without cache:
‚Üí 10,000 DB calls

With cache:
‚Üí 1 DB call
‚Üí 9,999 served from memory üöÄ

Types of Caching in ASP.NET Core

1. In-Memory Cache (IMemoryCache)
Stored in: Server RAM

Best for:

Single server apps
Small-medium systems

public class ProductService
{
    private readonly IMemoryCache _cache;
    private readonly AppDbContext _context;

    public ProductService(IMemoryCache cache, AppDbContext context)
    {
        _cache = cache;
        _context = context;
    }

    public async Task<List<Product>> GetProducts()
    {
        if (!_cache.TryGetValue("products", out List<Product> products))
        {
            products = await _context.Products.ToListAsync();

            _cache.Set("products", products,
                TimeSpan.FromMinutes(5));
        }

        return products;
    }
}
Pros

‚úî Very fast
‚úî Easy to implement

Cons

‚ùå Not shared across multiple servers
‚ùå Data lost when app restarts

2. Distributed Cache (Redis, SQL, etc.)

Stored in: External cache server (Redis)

Best for:

Microservices
Load-balanced systems
Cloud apps

Why Redis?

Extremely fast
Shared across multiple instances

3. Response Caching

Caches full HTTP response.
[ResponseCache(Duration = 60)]
Good for:

GET endpoints
Public data

4. Output Caching (.NET 7+)

Modern version of response caching.

builder.Services.AddOutputCache();
app.UseOutputCache();

Cache Expiration Strategies
üî∏ Absolute Expiration
Expires after fixed time.
TimeSpan.FromMinutes(5)

üî∏ Sliding Expiration
Resets timer on each access.
options.SetSlidingExpiration(TimeSpan.FromMinutes(5));

| Strategy      | Meaning                      |
| ------------- | ---------------------------- |
| Cache Aside   | App checks cache first       |
| Write Through | Update DB + Cache together   |
| Write Back    | Update cache first, DB later |

When NOT to Use Cache

‚ùå Frequently changing data
‚ùå Highly personalized data
‚ùå Sensitive data

18. What is Rate Limiting?
Rate limiting restricts how many requests a client can make in a specific time period.

Example:

100 requests per minute per user

Why Do We Need Rate Limiting?

Without rate limiting:

API abuse
DDoS attacks
Server overload
Increased cloud cost

With rate limiting:

Fair usage
System protection
Stable performance

Real-World Example

Imagine:

1 user sends 10,000 requests per second

Without rate limiting:
‚Üí Server crashes

With rate limiting:
‚Üí Only 100 allowed
‚Üí Rest blocked with 429 error

Common Rate Limiting Algorithms
Fixed Window

Example:

100 requests per minute

Resets every minute

Simple but can spike at boundary.

üîπ Sliding Window

More accurate version.
Counts requests in rolling time window.

Token Bucket (Most Popular)

Tokens are added at fixed rate

Each request consumes 1 token
If no token ‚Üí blocked
Allows bursts but controls average rate.

builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("fixed", opt =>
    {
        opt.PermitLimit = 100;
        opt.Window = TimeSpan.FromMinutes(1);
    });
});
app.UseRateLimiter();
[EnableRateLimiting("fixed")]
public IActionResult Get()
{
    return Ok("Hello");
}

What Happens When Limit Exceeded?
HTTP 429 - Too Many Requests

Rate Limiting Strategies

Per IP
Per User
Per API Key
Global limit
Per endpoint

| Feature              | Caching       | Rate Limiting  |
| -------------------- | ------------- | -------------- |
| Purpose              | Improve speed | Protect system |
| Reduces DB load      | Yes           | No             |
| Controls abuse       | No            | Yes            |
| Improves scalability | Yes           | Yes            |

Caching improves performance by temporarily storing frequently requested data to reduce database calls. 
It can be in-memory or distributed like Redis. 
Rate limiting protects the API by restricting how many requests a client can make within a specific time window, 
preventing abuse and improving system stability.

19. What is ngOnInit in Angular?

ngOnInit is a lifecycle hook in Angular that is called once after the component is initialized.
It runs after Angular sets all input properties and before the view is fully rendered.
It is mainly used to perform initialization logic like API calls, default data loading, or setup tasks.

| Constructor                    | ngOnInit                                 |
| ------------------------------ | ---------------------------------------- |
| Used for dependency injection  | Used for initialization logic            |
| Called first                   | Called after constructor                 |
| Should not contain heavy logic | Safe place for API calls                 |
| Runs when class is created     | Runs after Angular initializes component |

üëâ Never call API in constructor.
üëâ Use ngOnInit() for:

Calling REST APIs
Initializing variables
Subscribing to services
Setting default values

OnInit is an interface(contract) which contains ngOnInit method.

20. What is selector and Template?
A selector is used to identify each component uniquely in the component tree


A template defines the HTML view of a component.
It controls:

UI structure
Data binding
Directives
Event binding

Two Ways to Define Template
1. Inline Template
@Component({
  selector: 'app-employee',
  template: `
    <h2>{{ name }}</h2>
    <button (click)="changeName()">Change</button>
  `
})

2. External Template (Best Practice)
@Component({
  selector: 'app-employee',
  templateUrl: './employee.component.html'
})

Then in employee.component.html:
<h2>{{ name }}</h2>
<button (click)="changeName()">Change</button>

21. What are Observable and Promise?

Promise : A Promise represents a single future value.
üëâ It is used for asynchronous operations
üëâ It resolves once (success or failure)

let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Data received");
  }, 2000);
});

promise.then(data => console.log(data));

‚úî Executes once
‚úî Returns single value
‚úî Cannot be cancelled

Promise States

Pending
Fulfilled (resolved)
Rejected

Observable : An Observable is a stream of values over time.
üëâ It can emit:

Multiple values
Over a period of time
Can be cancelled
Supports operators (map, filter, etc.)

Angular uses RxJS Observables heavily (especially in HttpClient).

import { Observable } from 'rxjs';

let observable = new Observable(observer => {
  observer.next("First value");
  observer.next("Second value");
  observer.complete();
});

observable.subscribe(data => console.log(data));

‚úî Can emit multiple values
‚úî Supports cancellation
‚úî Lazy execution

How Angular Uses Observables
this.http.get("api/users")
    .subscribe(data => {
        console.log(data);
    });
Angular‚Äôs HttpClient returns Observable, not Promise.

| Feature         | Promise | Observable              |
| --------------- | ------- | ----------------------- |
| Values          | Single  | Multiple                |
| Execution       | Eager   | Lazy                    |
| Cancelable      | ‚ùå No   | ‚úî Yes (unsubscribe)    |
| Operators       | Limited | Powerful RxJS operators |
| Used in Angular | Rarely  | Mostly (HttpClient)     |

Key Interview Differences
1. Execution
Promise
let p = new Promise(...); // Executes immediately

Observable
let obs = new Observable(...); // Executes only when subscribed

üëâ Observable is lazy.

2. Cancellation
let subscription = observable.subscribe();
subscription.unsubscribe(); // Stops execution

‚ùå Promise cannot be cancelled

3. Multiple Values
Promise:
resolve("One");
resolve("Two"); // ignored

Observable:
observer.next("One");
observer.next("Two"); // both emitted

| Use Case                   | Choose     |
| -------------------------- | ---------- |
| Single async result        | Promise    |
| API calls in Angular       | Observable |
| Real-time data (WebSocket) | Observable |
| Complex async chains       | Observable |

Converting Between Them


import { firstValueFrom } from 'rxjs';
Observable ‚Üí Promise

let result = await firstValueFrom(this.http.get(...));

A Promise handles a single asynchronous value and executes immediately, 
while an Observable can emit multiple values over time, supports cancellation, and is lazy.
Angular prefers Observables because they provide powerful operators and better control over asynchronous streams.

üëâ Why Angular HttpClient returns Observable instead of Promise?

Answer:

Supports multiple values
Supports cancellation
Works well with RxJS operators
More powerful for reactive programming

22. What is RxJS?
RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables.

üëâ It helps manage asynchronous data streams like:

HTTP requests
User input events
WebSockets
Timers
Real-time updates

Angular heavily depends on RxJS.

Reactive programming means: Reacting to data as it arrives over time. 

Core Concepts of RxJS
1. Observable : A stream of data over time.
import { of } from 'rxjs';

const obs$ = of(1, 2, 3);
obs$.subscribe(value => console.log(value));

2. Observer : The object that receives values.
obs$.subscribe({
  next: value => console.log(value),
  error: err => console.log(err),
  complete: () => console.log("Done")
});

3. Subscription : Represents execution of Observable.
const sub = obs$.subscribe();
sub.unsubscribe();

‚úî Important to avoid memory leaks in Angular

Flow:

Observable emits data
Operators transform data
Observer receives final result

üëâ The Observable produces (or pushes) values
üëâ Those values are sent to the Observer (subscriber)
üëâ The Observer reacts to them

Simple Explanation

Think of an Observable like a YouTube live stream üé•
Think of the Observer like a viewer

Stream produces content ‚Üí Observable
Viewer watches content ‚Üí Observer
Viewer must subscribe ‚Üí subscribe()
No subscription = no data flow.

RxJS Operators : Operators are functions that transform data streams.

1. map() : Transforms each value.
import { map } from 'rxjs/operators';

this.http.get('/users')
  .pipe(
    map(data => data['result'])
  )
  .subscribe(res => console.log(res));

2. filter() : Filters values.
import { filter } from 'rxjs/operators';

of(1,2,3,4)
  .pipe(filter(x => x > 2))
  .subscribe(console.log);

3. switchMap() : Used in HTTP chaining, Cancels previous request if new one comes.
‚úî Used in search boxes
‚úî Prevents multiple API calls

4. mergeMap() : Runs multiple requests in parallel.

5. tap() : Used for debugging (side effects).