What is LINQ?
LINQ (Language Integrated Query) is a feature in .NET that allows you to query data using C# syntax, regardless of where the data comes from.
LINQ is a .NET feature that allows querying different data sources using a unified, type-safe C# syntax.

ğŸ‘‰ You can query:

Collections (List, Array)
Databases (Entity Framework)
XML
In-memory objects
One syntax, multiple data sources.

Why LINQ is Important?
Without LINQ:
foreach (var emp in employees)
{
    if (emp.Salary > 50000)
    {
        result.Add(emp);
    }
}

With LINQ:
var result = employees.Where(e => e.Salary > 50000).ToList();

âœ” Cleaner code
âœ” Readable
âœ” Less error-prone
âœ” Strongly typed

How LINQ Works (Conceptually)
Write LINQ query in C#
LINQ provider (Objects / EF / SQL) translates it
Data source executes it
Results returned as objects

Types of LINQ
1ï¸. LINQ to Objects - Used with in-memory collections.
var names = list.Where(x => x.StartsWith("A"));

2. LINQ to Entities (EF) - Used with databases via Entity Framework.
var emps = context.Employees
                  .Where(e => e.Department == "IT")
                  .ToList();
â¡ Converted to SQL internally

3. LINQ to XML - Used to query XML data.

LINQ Syntax Types.
1. Method Syntax (Most Used)
var result = employees
             .Where(e => e.Age > 30)
             .Select(e => e.Name)
             .ToList();

2. Query Syntax (SQL-like)
var result = from e in employees
             where e.Age > 30
             select e.Name;

ğŸ‘‰ Both produce the same result

Common LINQ Operators (Very Important)
| Operator         | Purpose           |
| ---------------- | ----------------- |
| `Where`          | Filter            |
| `Select`         | Projection        |
| `OrderBy`        | Sorting           |
| `GroupBy`        | Grouping          |
| `Any`            | Check existence   |
| `All`            | Check condition   |
| `FirstOrDefault` | Get first or null |
| `Count`          | Count records     |

Deferred vs Immediate Execution (INTERVIEW FAVORITE)

Deferred Execution : Query executes only when data is accessed.
var query = employees.Where(e => e.Age > 30);
// Not executed yet
Executed when: query.ToList();

Immediate Execution : Executes immediately.
employees.Where(e => e.Age > 30).ToList();

LINQ vs SQL (Quick Comparison)

| LINQ                  | SQL               |
| --------------------- | ----------------- |
| Type-safe             | Not type-safe     |
| Compile-time checking | Runtime errors    |
| Language integrated   | Separate language |
| Provider-based        | DB specific       |

Common Interview Questions

Q: Is LINQ slower than SQL?
â¡ Slight overhead, but optimized. EF converts LINQ to SQL.

Q: Can LINQ replace SQL?
â¡ For most cases yes, but raw SQL is still useful for complex queries.

Q: What is deferred execution?
â¡ Query runs only when results are enumerated.

LINQ with EF vs LINQ to Objects
Key Difference (Very Important)
| LINQ with EF                  | LINQ to Objects       |
| ----------------------------- | --------------------- |
| Runs on **database**          | Runs in **memory**    |
| Uses `IQueryable`             | Uses `IEnumerable`    |
| Converted to **SQL**          | Executed by CLR       |
| More efficient for large data | Slower for large data |

Example â€“ LINQ with EF (Database)
var emps = context.Employees
                  .Where(e => e.Salary > 50000)
                  .ToList();
ğŸ‘‰ SQL runs in DB: SELECT * FROM Employees WHERE Salary > 50000
âœ” Filtering happens in DB

Example â€“ LINQ to Objects (In-Memory)
var emps = employeesList
           .Where(e => e.Salary > 50000)
           .ToList();
âŒ All data already loaded into memory
âŒ Filtering happens in application

2ï¸. Performance Tips in LINQ (VERY IMPORTANT)
âœ… Best Practices
1. Filter Early : context.Employees.Where(e => e.IsActive);
âŒ Donâ€™t filter after ToList()

2. Select Only Required Columns : context.Employees.Select(e => new { e.Name, e.Salary });
âŒ Avoid: context.Employees.ToList();

3. Use Any() instead of Count() : context.Employees.Any(e => e.IsActive);
âŒ Avoid: context.Employees.Count() > 0;

4. Use AsNoTracking() for Read-Only Queries : context.Employees.AsNoTracking().ToList();
âœ” Faster
âœ” Less memory

5. Avoid Complex Methods Inside LINQ (EF) : âŒ EF cannot convert custom C# methods to SQL.

6. Use Pagination : 
context.Employees
       .Skip(20)
       .Take(10)
       .ToList();

LINQ Interview Coding Problems

Problem 1: Get Second Highest Salary
var secondHighest = employees
    .OrderByDescending(e => e.Salary)
    .Skip(1)
    .FirstOrDefault();

Problem 2: Count Employees by Department
var result = employees
    .GroupBy(e => e.Department)
    .Select(g => new
    {
        Department = g.Key,
        Count = g.Count()
    });

Problem 3: Check if Any Employee Salary > 1L
bool exists = employees.Any(e => e.Salary > 100000);

ğŸ”¹ Problem 4: Remove Duplicate Records
var distinct = employees
    .GroupBy(e => e.Email)
    .Select(g => g.First());

ğŸ”¹ Problem 5: Top 3 Highest Paid Employees
var top3 = employees
    .OrderByDescending(e => e.Salary)
    .Take(3);

IQueryable vs IEnumerable (ğŸ”¥ MOST IMPORTANT ğŸ”¥)
Core Difference
| IEnumerable             | IQueryable            |
| ----------------------- | --------------------- |
| In-memory execution     | Deferred DB execution |
| Runs in CLR             | Runs in database      |
| Suitable for small data | Best for large data   |
| LINQ to Objects         | LINQ with EF          |

IEnumerable Example : 
IEnumerable<Employee> data = context.Employees.ToList();
var result = data.Where(e => e.Age > 30);

âŒ DB already hit
âŒ Filtering in memory

IQueryable Example
IQueryable<Employee> data = context.Employees;
var result = data.Where(e => e.Age > 30);

âœ” SQL generated
âœ” Filtering in DB

When to Use What?
| Scenario             | Use           |
| -------------------- | ------------- |
| Database querying    | `IQueryable`  |
| In-memory processing | `IEnumerable` |
| Reusable filters     | `IQueryable`  |
| Small collections    | `IEnumerable` |

IQueryable executes queries on the data source like a database, while IEnumerable executes queries in memory. Using IQueryable with Entity Framework improves performance by pushing filtering to the database.

Q: What happens if we call ToList() early?
ğŸ‘‰ Query executes immediately and loses IQueryable benefits.